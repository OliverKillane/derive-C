include(FetchContent)

if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
  set(COVERAGE_FLAGS
    -fprofile-instr-generate
    -fcoverage-mapping
  )
endif()

# JUSTIFY: Deprecated declarations off
#  - Rapidcheck contains cpp23 deprecated features
add_compile_options(-Wno-deprecated-declarations)
add_compile_options(${COVERAGE_FLAGS})
add_link_options(${COVERAGE_FLAGS})

FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG v1.14.0
)
FetchContent_MakeAvailable(googletest)

set(RC_ENABLE_GTEST ON CACHE BOOL "Rapidcheck GTest Support" FORCE)
FetchContent_Declare(
  rapidcheck
  GIT_REPOSITORY https://github.com/emil-e/rapidcheck.git
  GIT_TAG ff6af6fc683159deb51c543b065eba14dfcf329b # Latest as of 3/30/2025
)
FetchContent_MakeAvailable(rapidcheck)

include(GoogleTest)

file(GLOB_RECURSE TEST_CPP_FILES CONFIGURE_DEPENDS *.cpp)
set(ALL_TEST_EXECUTABLES)

# JUSTIFY: Test per cpp executable
#  - To be able to run all tests in parallel, so a binary per structure/test suite.
foreach(TEST_FILE ${TEST_CPP_FILES})
  file(RELATIVE_PATH REL_PATH ${CMAKE_CURRENT_SOURCE_DIR} ${TEST_FILE})
  string(REPLACE "/" "_" TEST_NAME ${REL_PATH})
  string(REPLACE ".cpp" "" TEST_NAME ${TEST_NAME})
  
  add_executable(${TEST_NAME} ${TEST_FILE})
  target_compile_definitions(${TEST_NAME} PRIVATE ENABLE_MOCKING)
  target_link_libraries(${TEST_NAME}
    PRIVATE
      derivec
      gtest
      gmock
      gtest_main
      rapidcheck
      rapidcheck_gtest
  )
  
  gtest_discover_tests(${TEST_NAME}
    DISCOVERY_TIMEOUT 30
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    PROPERTIES LABELS "correctness"
    ENVIRONMENT
      "RC_PARAMS=max_success=20000"
  )
  
  list(APPEND ALL_TEST_EXECUTABLES ${TEST_NAME})
endforeach()

if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
  find_program(LLVM_COV_EXECUTABLE NAMES llvm-cov)
  find_program(LLVM_PROFDATA_EXECUTABLE NAMES llvm-profdata)
  find_program(GENHTML_EXECUTABLE NAMES genhtml)

  set(COVERAGE_OBJECTS)
  foreach(TEST_EXEC ${ALL_TEST_EXECUTABLES})
    list(APPEND COVERAGE_OBJECTS "--object=${CMAKE_CURRENT_BINARY_DIR}/${TEST_EXEC}")
  endforeach()

  set(COVERAGE_DIR ${CMAKE_BINARY_DIR}/coverage)
  set(COVERAGE_ARGS
    --instr-profile=${COVERAGE_DIR}/coverage.profdata
    "--ignore-filename-regex=(^|.*/)(test|build)/.*" # Regex not cmake syntax
  )

  if(DEVELOP AND LLVM_COV_EXECUTABLE AND LLVM_PROFDATA_EXECUTABLE AND GENHTML_EXECUTABLE)    
    add_custom_target(coverage
      DEPENDS ${ALL_TEST_EXECUTABLES}
      COMMENT "üîç Running llvm-cov ‚Üí HTML coverage report (Clang/LLVM)"
      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
      COMMAND ${CMAKE_COMMAND} -E remove_directory ${COVERAGE_DIR}
      COMMAND ${CMAKE_COMMAND} -E make_directory ${COVERAGE_DIR}
      COMMAND ${CMAKE_COMMAND} 
        -E env 
          LLVM_PROFILE_FILE=${COVERAGE_DIR}/coverage_%p_%m.profraw 
        ${CMAKE_CTEST_COMMAND} 
          -L correctness 
          -j
          --output-on-failure
      
      # JUSTIFY: Shell scripting from cmake
      #  - We need to collect multiple files (wth names generated by the previous command - 
      #    not available at cmake configure time).
      #  - cmake cannot do `*` patterns itself, a fully platform agnostic way requires generating 
      #    an additional with a cmake list, this is much more complex.
      #  Hence we are shell dependent here
      COMMAND /bin/sh -c "${LLVM_PROFDATA_EXECUTABLE} merge -sparse ${COVERAGE_DIR}/*.profraw -o ${COVERAGE_DIR}/coverage.profdata"
      
      COMMAND ${LLVM_COV_EXECUTABLE} 
        report 
        ${COVERAGE_OBJECTS} 
        ${COVERAGE_ARGS}
      
      COMMAND ${LLVM_COV_EXECUTABLE} 
        show
        ${COVERAGE_OBJECTS}
        ${COVERAGE_ARGS}
        --format=html
        --show-branches=count
        --show-line-counts
        --show-regions
        --output-dir=coverage_html
      COMMENT "Running tests and generating coverage report (clang)"
      VERBATIM
      USES_TERMINAL
    )
  endif()
endif()
